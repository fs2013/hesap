# AUTOGENERATED! DO NOT EDIT! File to edit: 02_optionsseasonal.ipynb (unless otherwise specified).

__all__ = ['weekly_returns', 'build_weekly_db']

# Cell

"""This module contains methods to create and update daily price and weekly
performance for the desired assets locally. Also for a given week, the most
optimal assets (with highest performance probability based on the history)
are identified for possible MattChoi's type option strategy.
by faf
Copyright 2021 Fafs
License: http://creativecommons.org/licenses/by/4.0/
"""

import os

import numpy as np
import pandas as pd

from typing import List


def weekly_returns(df):
    """
    Processes the daily adjusted close prices to produce 35 to 45 week forward
    performances
    """
    df.loc[:, 'year'] = df.index.isocalendar().year
    df.loc[:, 'week'] = pd.Int64Index(df.index.isocalendar().week)
    for n in range(35, 46):
        df.loc[:, f'forward{n}'] = df.loc[:, 'adj_close'].shift(-n) / df.loc[:, 'adj_close']

    rets, forwards, means = {}, {}, []
    for week in range(2, 52):
        if week not in df.week.unique(): continue
        forwards[week] = df.loc[df.week == week,
                                ['forward35', 'forward36', 'forward37',
                                 'forward38', 'forward39', 'forward40',
                                 'forward41', 'forward42', 'forward43',
                                 'forward44', 'forward45', 'year']]

        years = sorted(forwards[week].year.unique())
        rets[week] = []
        for year in years:
            returns = []
            for n in range(35,46):
                returns.extend(forwards[week].loc[(forwards[week].year == year), f'forward{n}'].tolist())
            rets[week].append({
                'year': year,
                'min': min(returns),
                'max': max(returns),
                'mean': np.mean(returns),
                'std': np.std(returns),
                'up_conf': np.sum([1 for r in returns if r > 1]) / len(returns) * 100,
                'dn_conf': np.sum([1 for r in returns if r < 1]) / len(returns) * 100
            })
        rets[week] = pd.DataFrame(rets[week])

        up_mean = round(rets[week].up_conf.mean(), 2)
        dn_mean = round(rets[week].dn_conf.mean(), 2)
        means.append({'week': week, 'up_mean': up_mean, 'dn_mean': dn_mean})
        if up_mean > 80 or dn_mean > 80:
            print(f'{week:2}:\t{up_mean}\t{dn_mean}')
    return rets, means


def build_weekly_db(tickers: List[str],
                    db_path: str,
                    start_date: str = '2000-01-01'
                   ) -> None:
    if tickers is None or len(tickers) == 0: return
    for d in [db_path, f'{db_path}/prices', f'{db_path}/rets',
              f'{db_path}/mean_rets']:
        os.makedirs(d, exist_ok=True)
    for i, ticker in enumerate(tickers):
        prices = get_history_yf(ticker.replace('.', '-'),
                                start_date=start_date)
        prices.to_csv(f'{db_path}/prices/{ticker}.csv')
        print(f'={i+1:4}{"="*4}{ticker:4}{"="*20}')
        rets, means = weekly_returns(prices)

        try:
            pd.DataFrame.from_dict(data=rets, orient='index').to_csv(f'{db_path}/rets/{ticker}.csv', header=False)
            pd.DataFrame(means).to_csv(f'{db_path}/mean_rets/{ticker}.csv')
        except:
            print(f'could not create dataframe for {ticker}')